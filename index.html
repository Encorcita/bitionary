<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Yapma Aŋlak</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bytesized&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=more_horiz" />
  
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --vh: 1vh;
      --binance-gold: #fcd434;
      --binance-dark-gold: #f0b90b;
      --binance-black: #191a1f;
      --thinking-color: #2ebd85;
      --thinking-color2: #112822;
      --binance-white: #ffffff;
--binance-dark-grey: #1e2026;
      --binance-light-grey: #464d57;
      --search-input-bg: #29313c;
    }
    y {
      color: var(--binance-gold);
    }
    k {
      color: var(--binance-gold);
      font-weight: bold;
    }
    ::selection {
      background-color: #fdd534;
      color: var(--binance-black);
    }
    body {
      font-family: 'IBM Plex Sans', sans-serif;
      background-color: var(--binance-black);
      color: var(--binance-white);
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    html, body {
        height: 100%;
        overflow: hidden;
    }
    #app-container {
      height: calc(var(--vh, 1vh) * 100);
      overflow: hidden; 
      background-color: var(--binance-black);
    }
    #chat-container.is-dragging {
        cursor: grabbing;
    }
    .transition-all { transition: all 0.5s ease-in-out; }
    .chat-container::-webkit-scrollbar { width: 0; height: 0; background: transparent; }
    
    #input-container {
        display: flex;
        border-radius: 12px;
        overflow: hidden;
        position: relative;
        background-color: var(--search-input-bg);
    }

    #chat-input {
      background-color: transparent;
      color: var(--binance-white);
      border: none;
      border-radius: 0;
      box-shadow: none;
      flex-grow: 1;
      position: relative;
      z-index: 2;
      -webkit-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }
    #chat-input::placeholder {
      transition: opacity 0.5s ease-in-out;
      opacity: 1;
      color: #5d626e;
    }
    #chat-input.hiding-placeholder::placeholder {
      opacity: 0;
    }
    #autocomplete-ghost {
        transition: opacity 0.3s ease-in-out;
    }
    #autocomplete-ghost.fading {
        opacity: 0;
    }
    
    #submit-button {
      box-shadow: none;
      border-radius: 0;
      flex-shrink: 0;
    }
    .ai-message {
      background-color: transparent !important;
      box-shadow: none !important;
      color: var(--binance-white);
    }
    .suggestion-link {
      display: inline-block;
      margin: 4px 4px 0 0;
      opacity: 0;
      transform: translateY(15px);
      transition: opacity 0.4s ease-out, transform 0.4s ease-out, box-shadow 0.2s ease-in-out;
      background-color: #2a3139;
      color: #eff5fc;
    }
    .suggestion-link:focus {
        outline: none;
    }
    .suggestion-link.visible {
        opacity: 1;
        transform: translateY(0);
    }
    #chat-container.ai-is-typing .suggestion-link,
    #chat-container.is-loading .suggestion-link {
        opacity: 0.3;
        pointer-events: none;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }
    .typing-cursor {
      display: inline-block;
      transform: scale(1.5);
      margin: 0 0.1em;
      animation: blink 1s step-end infinite;
      color: var(--thinking-color);
    }
    .vocab-load-error .typing-cursor {
      color: #f7475c;
    }
    @keyframes scale-wave {
      0%, 100% {
        transform: scale(0.1);
      }
      50% {
        transform: scale(1.4);
      }
    }
    .loading-dots {
      display: flex;
      gap: 4px;
      align-items: center;
      margin-top: 10px;
    }
    .loading-dots span {
      width: 4px;
      height: 4px;
      background-color: var(--thinking-color);
      border-radius: 50%;
      animation: scale-wave 1.4s infinite ease-in-out;
    }
    .loading-dots.error span {
      background-color: #f7475c;
    }
    .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
    .loading-dots span:nth-child(3) { animation-delay: 0.4s; }
    .loading-dots span:nth-child(4) { animation-delay: 0.6s; }
    
    #submit-button-icon {
      transition: all 0.2s ease-in-out;
    }
    
    #submit-button.empty-state {
        background-color: var(--binance-light-grey);
        color: var(--binance-dark-grey);
        box-shadow: none;
        cursor: pointer;
    }
    #submit-button.loading {
        background-color: var(--binance-gold);
        color: var(--binance-black);
        box-shadow: none;
        cursor: pointer;
    }
    #submit-button.disabled-loading {
        background-color: var(--binance-light-grey) !important;
        color: var(--binance-dark-grey) !important;
        cursor: not-allowed;
    }
    .has-ripple {
        position: relative;
        overflow: hidden;
        -webkit-tap-highlight-color: transparent;
    }
    .ripple {
        position: absolute;
        border-radius: 50%;
        transform: scale(0);
        animation: ripple-effect 0.6s linear;
        background-color: rgba(0, 0, 0, 0.2);
        pointer-events: none;
    }
    @keyframes ripple-effect {
        to {
            transform: scale(4);
            opacity: 0;
        }
    }
    .message-wrapper {
      display: flex;
      margin-bottom: 1rem;
      position: relative;
    }

    .message-bubble {
        max-width: 90%; 
        padding: 0.75rem;
        border-radius: 0.5rem;
        overflow-wrap: break-word;
        word-wrap: break-word;
        line-height: 1.5; 
        position: relative;
    }
    
    #ai-title {
      font-family: 'Bytesized', sans-serif;
      color: var(--binance-gold);
    }
    
    .user-message .message-bubble {
        background-color: var(--binance-black);
        border: 1px solid var(--binance-light-grey);
        box-shadow: none;
        color: var(--binance-white);
    }

    .ai-message .message-bubble {
        background-color: transparent;
        box-shadow: none;
        padding-left: 0;
        padding-right: 0;
    }
    
.message-meta {
    position: absolute;
    top: 0%;
    right: 0;
    transform: translateY(-50%) rotate(90deg);
    font-size: 0.6rem;
    font-weight: normal;
    color: var(--binance-light-grey);
    pointer-events: none;
}

    .thinking-indicator {
      background-color: var(--thinking-color2);
      color: var(--thinking-color);
      text-transform: capitalize;
      letter-spacing: 0.05em;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      padding: 3px 8px;
      border-radius: 5px;
    }
    
    .system-indicator {
      background-color: #011535;
      color: #285fd5;
      text-transform: capitalize;
      letter-spacing: 0.05em;
      padding: 3px 8px;
      border-radius: 5px;
      display: flex;
      align-items: center;
    }
    
    .welcome-indicator {
      background-color: #2a1a3e;
      color: #be93fd;
      text-transform: capitalize;
      letter-spacing: 0.05em;
      padding: 3px 8px;
      border-radius: 5px;
      display: flex;
      align-items: center;
    }

    .thinking-indicator::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform: translateX(-100%);
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.25), transparent);
      animation: shimmer 1.8s infinite linear;
    }

    @keyframes shimmer {
      100% {
        transform: translateX(100%);
      }
    }

    .language-info {
       background-color: #2e2a1e;
       color: var(--binance-gold);
       text-transform: capitalize;
       padding: 3px 8px;
       border-radius: 5px;
       display: flex;
       align-items: center;
    }
    
    @keyframes tag-fade-in {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes tag-fade-out {
      from {
        opacity: 1;
        transform: scale(1);
      }
      to {
        opacity: 0;
        transform: scale(0.8);
      }
    }

    .tag-anim-in {
      animation: tag-fade-in 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
    }

    .tag-anim-out {
      animation: tag-fade-out 0.2s ease-in forwards;
    }

    .message-content-wrapper {
        display: flex;
        width: 100%;
    }

    .user-message .message-content-wrapper {
        justify-content: flex-end;
    }

    .ai-message .message-content-wrapper {
        justify-content: flex-start;
    }
    
    #footer-indicator-container {
        position: absolute;
        right: 4.5rem; 
        top: 0;
        height: 100%;
        display: flex;
        align-items: center;
        z-index: 3;
        pointer-events: none; 
        transition: opacity 0.2s ease-in-out;
    }

    #footer-indicator-container.is-overlapped {
        opacity: 0.55;
    }

    .comment-section {
      position: relative;
      padding: 0.5rem 0.5rem 0.5rem 1rem;
      margin-top: 0.75rem;
      border-left: 3px solid transparent;
      transition: border-color 0.3s ease-in, background-color 0.3s ease-in;
      border-radius: 6px;
      background-color: transparent;
    }

    .comment-section.visible {
      border-left-color: #8d60ef;
      background-color: rgba(141, 96, 239, 0.1);
    }

    .comment-section p {
      margin: 0;
      padding: 0;
    }
    
    .comment-word {
      display: inline-block;
      opacity: 0;
      filter: blur(2px);
      transform: translateY(10px);
      transition: opacity 0.5s ease-out, filter 0.1s ease-out, transform 0.1s cubic-bezier(0.215, 0.610, 0.355, 1.000);
    }

    .comment-word.visible {
        opacity: 1;
        filter: blur(0);
        transform: translateY(0);
    }
    
    /**
     * START: Scroll Gradient Styles & Fixes
     */
    .message-bubble.truncated {
        max-height: 7.5em; 
        overflow: hidden;
        position: relative;
        box-sizing: border-box;
        padding-top: 0;
        padding-bottom: 0;
    }

    .message-bubble.truncated::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 2rem;
        background: linear-gradient(var(--binance-black), transparent);
        pointer-events: none;
        z-index: 1;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
    }
    
    .message-bubble.truncated.scrolled-past-top::before {
        opacity: 1;
    }

    .message-bubble.truncated::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 50%;
        background: linear-gradient(transparent, var(--binance-black)); /* FIX: Applied same smoothing as top gradient */
        pointer-events: none;
        z-index: 1;
        transition: opacity 0.3s ease-in-out;
    }

    .message-bubble.truncated.scrolled-to-bottom::after {
        opacity: 0;
    }

    .read-more-indicator {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 35px;
        height: 15px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: var(--binance-light-grey);
        z-index: 2;
        border-top-right-radius: 0.5rem;
    }

    .read-more-indicator .material-symbols-outlined {
        color: var(--binance-black);
        font-size: 22px;
    }

    .message-bubble.truncated p {
        height: 100%;
        overflow-y: scroll;
        padding-right: 15px;
        cursor: grab;
        scrollbar-width: none;
        -ms-overflow-style: none;
        padding-top: 0.75rem;
        padding-bottom: 1.5rem;
    }
    .message-bubble.truncated p::-webkit-scrollbar {
        display: none;
    }
    /**
     * END: Scroll Gradient Styles & Fixes
     */
  </style>
</head>
<body class="">
  <div id="app-container" class="max-w-[700px] mx-auto flex flex-col relative">
    
    <header class="absolute top-0 left-0 right-0 pt-4 px-4 pb-1 z-10">
      <h1 id="ai-title" style="font-size: 2rem; transform-origin: top left; transition: transform 0.1s linear, opacity 0.1s linear;">bitionary</h1>
    </header>

    <main id="chat-container" class="w-full flex-1 overflow-y-auto chat-container px-4 pt-16" style="z-index: 1; position: relative; background-color: transparent;">
    </main>

    <footer id="footer" class="absolute bottom-0 left-0 w-full bg-transparent px-4 pb-4 pt-2" style="z-index: 2;">
      <form id="prompt-form" class="w-full">
        <div id="input-container" class="h-14">
          <div id="footer-indicator-container"></div>
          <div id="autocomplete-ghost" class="absolute top-0 left-0 h-full w-full flex items-center pl-4 pr-4 pointer-events-none" style="z-index: 1; color: #5d626e;"></div>
          <input type="text" id="chat-input" placeholder="" class="w-full h-full pl-4 pr-4 focus:outline-none" tabindex="1" autocomplete="off">
          <button id="submit-button" type="submit" class="h-full w-14 focus:outline-none transition-colors flex items-center justify-center has-ripple">
            <svg id="submit-button-icon" xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              </svg>
          </button>
        </div>
      </form>
    </footer>
  </div>

  <script>
    let vocabularyData = {};
    let backlinksData = {}; // Stores etymological backlinks
    let vocabularyLoadFailed = false;

    const form = document.getElementById('prompt-form');
    const input = document.getElementById('chat-input');
    const chatContainer = document.getElementById('chat-container');
    const submitButton = document.getElementById('submit-button');
    const submitButtonIcon = document.getElementById('submit-button-icon');
    const footer = document.getElementById('footer');
    const autocompleteGhost = document.getElementById('autocomplete-ghost');

    const ICONS = {
      send: '<path stroke-linecap="round" stroke-linejoin="round" d="M12 17V7m-5 5 5-5 5 5" />',
      stop: '<path stroke-linecap="round" stroke-linejoin="round" d="M6 6h12v12H6z" />'
    };

    let currentWord = '';
    let currentSuggestion = '';
    let isAITyping = false;
    let isLoading = false;
    let typewriterInterval = null;
    let thinkingTimeout = null;
    let scrollAnimationId = null;
    let liveScrollAnimationId = null;

    let userHasScrolledUp = false;

    let suggestionAnimationInterval = null;
    let currentMatches = [];
    let currentSuggestionIndex = 0;

    const textMeasureSpan = document.createElement('span');

    function setupTextMeasureSpan() {
    textMeasureSpan.style.position = 'absolute';
    textMeasureSpan.style.visibility = 'hidden';
    textMeasureSpan.style.height = 'auto';
    textMeasureSpan.style.width = 'auto';
    textMeasureSpan.style.whiteSpace = 'nowrap';
    document.getElementById('app-container').appendChild(textMeasureSpan);
}

    function handleIndicatorOverlap() {
        const chatInput = document.getElementById('chat-input');
        const indicatorContainer = document.getElementById('footer-indicator-container');
        const indicator = indicatorContainer.querySelector('span');

        if (!indicator || !chatInput.value) {
            indicatorContainer.classList.remove('is-overlapped');
            return;
        }

        const inputStyle = window.getComputedStyle(chatInput);
        textMeasureSpan.style.font = inputStyle.font;
        textMeasureSpan.textContent = chatInput.value;

        const textWidth = textMeasureSpan.getBoundingClientRect().width;
        const inputRect = chatInput.getBoundingClientRect();
        const indicatorRect = indicator.getBoundingClientRect();

        const textEndPosition = inputRect.left + parseFloat(inputStyle.paddingLeft) + textWidth;

        if (textEndPosition > indicatorRect.left) {
            indicatorContainer.classList.add('is-overlapped');
        } else {
            indicatorContainer.classList.remove('is-overlapped');
        }
    }

    function interruptScrollAnimation() {
      if (scrollAnimationId) { cancelAnimationFrame(scrollAnimationId); scrollAnimationId = null; }
    }

    function smoothScrollToBottom(element, duration) {
        interruptScrollAnimation();
        const startPosition = element.scrollTop;
        const endPosition = element.scrollHeight - element.clientHeight;
        const distance = endPosition - startPosition;
        if (distance <= 0) return;
        let startTime = null;
        function animationStep(currentTime) {
            if (startTime === null) startTime = currentTime;
            const elapsedTime = currentTime - startTime;
            const t = Math.min(1, elapsedTime / duration);
            const easedProgress = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            element.scrollTop = startPosition + (distance * easedProgress);
            if (elapsedTime < duration) {
                scrollAnimationId = requestAnimationFrame(animationStep);
            } else {
                element.scrollTop = endPosition;
                scrollAnimationId = null;
            }
        }
        scrollAnimationId = requestAnimationFrame(animationStep);
    }

    function liveSmoothScroll() {
        if (!isAITyping || liveScrollAnimationId === null) {
            liveScrollAnimationId = null;
            return;
        }

        if(userHasScrolledUp) {
            liveScrollAnimationId = requestAnimationFrame(liveSmoothScroll);
            return;
        }

        const element = chatContainer;
        const targetScrollTop = element.scrollHeight - element.clientHeight;
        if (targetScrollTop <= 0) {
            liveScrollAnimationId = requestAnimationFrame(liveSmoothScroll);
            return;
        }

        const scrollDifference = targetScrollTop - element.scrollTop;
        if (Math.abs(scrollDifference) > 1) {
            element.scrollTop += scrollDifference * 0.1;
        } else {
            element.scrollTop = targetScrollTop;
        }
        liveScrollAnimationId = requestAnimationFrame(liveSmoothScroll);
    }

    function setViewportHeight() {
        let vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
    }

    function adjustChatContainerPadding() {
        if (footer && chatContainer) {
            const footerHeight = footer.offsetHeight;
            chatContainer.style.paddingBottom = `${footerHeight}px`;
        }
    }

    function updateSubmitButtonState() {
      const isEmpty = input.value.trim() === '';
      submitButton.disabled = false;
      submitButton.classList.remove('empty-state', 'loading', 'disabled-loading');
      submitButton.style.backgroundColor = '';
      submitButton.style.color = '';

      if (isLoading || isAITyping) {
        submitButton.classList.add('loading');
        submitButtonIcon.innerHTML = ICONS.stop;

        if (isLoading && !isAITyping) {
            submitButton.disabled = true;
            submitButton.classList.add('disabled-loading');
        }
      } else {
        if (isEmpty) {
          submitButton.classList.add('empty-state');
        } else {
          submitButton.style.backgroundColor = 'var(--binance-gold)';
          submitButton.style.color = 'var(--binance-black)';
        }
        submitButtonIcon.innerHTML = ICONS.send;
      }
    }

    function initializePlaceholderAnimation() {
        if (Object.keys(vocabularyData).length === 0) return;
        const words = Object.keys(vocabularyData);
        let currentIndex = -1;
        const changePlaceholder = () => {
            input.classList.add('hiding-placeholder');
            setTimeout(() => {
                let nextIndex;
                do {
                    nextIndex = Math.floor(Math.random() * words.length);
                } while (nextIndex === currentIndex);
                currentIndex = nextIndex;
                input.placeholder = words[currentIndex];
                input.classList.remove('hiding-placeholder');
            }, 500);
        };
        const firstIndex = Math.floor(Math.random() * words.length);
        currentIndex = firstIndex;
        input.placeholder = words[firstIndex];
        setInterval(changePlaceholder, 3000);
    }

    function initializeTitleAnimation() {
        const aiTitle = document.getElementById('ai-title');
        const chatContainer = document.getElementById('chat-container');
        const INITIAL_SCALE = 1.0, FINAL_SCALE = 0.5, INITIAL_OPACITY = 1.0, FINAL_OPACITY = 0.5, SCROLL_THRESHOLD = 18;
        function handleTitleScrollAnimation() {
            if (!aiTitle || !chatContainer) return;
            const scrollTop = chatContainer.scrollTop;
            const progress = Math.min(scrollTop / SCROLL_THRESHOLD, 1);
            const newScale = INITIAL_SCALE - ((INITIAL_SCALE - FINAL_SCALE) * progress);
            const newOpacity = INITIAL_OPACITY - ((INITIAL_OPACITY - FINAL_OPACITY) * progress);
            requestAnimationFrame(() => {
                aiTitle.style.transform = `scale(${newScale})`;
                aiTitle.style.opacity = newOpacity;
            });
        }
        chatContainer.addEventListener('scroll', handleTitleScrollAnimation);
        handleTitleScrollAnimation();
    }

    function buildBacklinks(vocabulary) {
        const newBacklinks = {};
        for (const entryWord in vocabulary) {
            const entryData = vocabulary[entryWord];
            if (entryData.etymology) {
                const etymologyLines = entryData.etymology.split('<br>');
                for (const line of etymologyLines) {
                    const trimmedLine = line.trim();
                    let type = null;
                    let content = '';
                    if (trimmedLine.startsWith('<')) {
                        type = 'direct'; 
                        content = trimmedLine.substring(1);
                    }
                    if (type) {
                        const potentialWords = content.split(' ');
                        for (const pWord of potentialWords) {
                            const cleanWord = pWord.replace(/<[^>]*>/g, "").replace(/[.,!?]/g, '').trim();
                            if (cleanWord) {
                                const lowerCleanWord = cleanWord.toLocaleLowerCase('tr-TR');
                                if (!newBacklinks[lowerCleanWord]) {
                                    newBacklinks[lowerCleanWord] = { direct: [], related: [] };
                                }
                                if (!newBacklinks[lowerCleanWord][type].includes(entryWord)) {
                                    newBacklinks[lowerCleanWord][type].push(entryWord);
                                }
                            }
                        }
                    }
                }
            }
        }
        backlinksData = newBacklinks;
    }

    function handleTruncatedScroll(e) {
        const p = e.target;
        if (!p || !p.closest('.message-bubble.truncated')) return;

        const bubble = p.closest('.message-bubble.truncated');
        const buffer = 5;

        if (p.scrollTop > buffer) {
            bubble.classList.add('scrolled-past-top');
        } else {
            bubble.classList.remove('scrolled-past-top');
        }

        const isAtBottom = p.scrollHeight - p.scrollTop - p.clientHeight < buffer;
        if (isAtBottom) {
            bubble.classList.add('scrolled-to-bottom');
        } else {
            bubble.classList.remove('scrolled-to-bottom');
        }
    }

    function initializeDragToScroll() {
        const container = document.getElementById('chat-container');
        let isDragging = false;
        let draggedElement = null;
        let startY;
        let startScrollTop;

        container.addEventListener('scroll', handleTruncatedScroll, true);

        function handleDragStart(e) {
            const p = e.target.closest('.message-bubble.truncated p');
            if (p && p.scrollHeight > p.clientHeight) {
                isDragging = true;
                draggedElement = p;
                startY = e.touches ? e.touches[0].pageY : e.pageY;
                startScrollTop = p.scrollTop;
                container.classList.add('is-dragging');
                e.preventDefault();
            }
        }

        function handleDragMove(e) {
            if (!isDragging || !draggedElement) return;
            const currentY = e.touches ? e.touches[0].pageY : e.pageY;
            const deltaY = currentY - startY;
            draggedElement.scrollTop = startScrollTop - deltaY;
        }

        function handleDragEnd() {
            if (isDragging) {
                isDragging = false;
                draggedElement = null;
                container.classList.remove('is-dragging');
            }
        }

        container.addEventListener('mousedown', handleDragStart);
        window.addEventListener('mousemove', handleDragMove);
        window.addEventListener('mouseup', handleDragEnd);
        
        container.addEventListener('touchstart', handleDragStart, { passive: false });
        window.addEventListener('touchmove', handleDragMove, { passive: false });
        window.addEventListener('touchend', handleDragEnd);
    }

    window.addEventListener('DOMContentLoaded', () => {
      setViewportHeight();
      adjustChatContainerPadding();
      initializeTitleAnimation();
      initializeRippleEffect();
      initializeOverscrollEffect();
      initializeDragToScroll();
      setupTextMeasureSpan();
      input.disabled = true;
      updateSubmitButtonState();

      chatContainer.addEventListener('scroll', () => {
          const buffer = 50;
          const isAtBottom = chatContainer.scrollHeight - chatContainer.scrollTop - chatContainer.clientHeight < buffer;
          userHasScrolledUp = !isAtBottom;
      }, { passive: true });

      fetch('vocabulary.json')
        .then(response => { if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); return response.json(); })
        .then(data => {
            Object.keys(data).forEach((key, index) => {
                data[key].vocabId = index + 1;
            });
            vocabularyData = data;
            buildBacklinks(vocabularyData);
            input.disabled = false;
            updateSubmitButtonState();
            initializePlaceholderAnimation();

            // ### START: UPDATED CODE ###
            const urlHash = window.location.hash.substring(1);
            if (urlHash && !isNaN(parseInt(urlHash, 10))) {
                const requestedId = parseInt(urlHash, 10);
                const entryKey = Object.keys(vocabularyData).find(key => vocabularyData[key].vocabId === requestedId);

                if (entryKey) {
                    const welcomeText = `Here is the explanation of the entry <y>${entryKey}</y> for you:<br><br>`;
                    const initialMessageWrapper = displayMessage("", "ai");
                    const p = initialMessageWrapper.querySelector('p');
                    p.dataset.language = 'system';
                    p.innerHTML = welcomeText;
                    
                    setTimeout(() => {
                        getAIResponse(entryKey);
                    }, 100);

                } else {
                    const p = displayMessage("", "ai").querySelector('p');
                    p.dataset.language = 'system';
                    typewriterEffect(p, `The requested entry with ID #${urlHash} could not be found.`);
                }
            } else {
              // Original welcome message
              const initialMessageElementWrapper = displayMessage("", "ai");
              const p = initialMessageElementWrapper.querySelector('p');
              p.dataset.language = 'welcome';
              typewriterEffect(p, "As a linguistic companion harboring <i>thousands</i> of morphemes, meanings, sources, and annotations within me, I stand ready to accompany your archaeological excavation through the depths of Proto-Turkic and Turkic dialects.");
            }
            // ### END: UPDATED CODE ###
        });

      chatContainer.addEventListener('scroll', updateLanguageTagOnScroll);
    });

    window.addEventListener('resize', () => {
        setViewportHeight();
        adjustChatContainerPadding();
    });

    function processWordSubmission(word) {
        const trimmedWord = word.trim();
        if (!trimmedWord) return;

        userHasScrolledUp = false;

        clearInterval(suggestionAnimationInterval);
        autocompleteGhost.textContent = '';
        currentSuggestion = '';
        displayMessage(trimmedWord, 'user');
        currentWord = trimmedWord;
        getAIResponse(currentWord);
    }

    form.addEventListener('submit', e => {
      e.preventDefault();
      if (input.disabled || submitButton.disabled) return;

      if (isLoading || isAITyping) {
        stopAll();
        return;
      }

      const wordFromInput = input.value.trim();
      if(wordFromInput === '') return;

      processWordSubmission(wordFromInput);
      input.value = '';
      updateSubmitButtonState();
      handleIndicatorOverlap();
    });

    input.addEventListener('input', () => {
        updateSubmitButtonState();
        handleAutocomplete();
        handleIndicatorOverlap();
    });

    function animateSuggestion() {
        autocompleteGhost.classList.add('fading');
        setTimeout(() => {
            if (currentMatches.length === 0) return;
            const nextSuggestion = currentMatches[currentSuggestionIndex];
            currentSuggestion = nextSuggestion;
            autocompleteGhost.textContent = currentSuggestion;
            currentSuggestionIndex = (currentSuggestionIndex + 1) % currentMatches.length;
            autocompleteGhost.classList.remove('fading');
        }, 300);
    }

    function handleAutocomplete() {
        clearInterval(suggestionAnimationInterval);
        autocompleteGhost.classList.remove('fading');
        const typedText = input.value;
        if (typedText.trim() === '' || Object.keys(vocabularyData).length === 0) {
            autocompleteGhost.textContent = '';
            currentSuggestion = '';
            currentMatches = [];
            return;
        }
        const lowerTypedText = typedText.toLocaleLowerCase('tr-TR');
        currentMatches = Object.keys(vocabularyData).filter(
            key => key.startsWith(lowerTypedText) && key !== lowerTypedText
        );
        if (currentMatches.length > 0) {
            currentSuggestionIndex = 0;
            animateSuggestion();
            if (currentMatches.length > 1) {
                suggestionAnimationInterval = setInterval(animateSuggestion, 2000);
            }
        } else {
            autocompleteGhost.textContent = '';
            currentSuggestion = '';
        }
    }

    input.addEventListener('keydown', (e) => {
        if ((e.key === 'Tab' || e.key === 'ArrowRight') && currentSuggestion) {
            if (input.selectionStart === input.value.length) {
                e.preventDefault();
                clearInterval(suggestionAnimationInterval);
                input.value = currentSuggestion;
                currentSuggestion = '';
                autocompleteGhost.textContent = '';
                input.dispatchEvent(new Event('input'));
            }
        }
    });

    function copyToClipboard(text) {
        let ta = document.createElement("textarea");
        ta.value = text;
        ta.style.position = "fixed"; ta.style.top = 0; ta.style.left = 0; ta.style.width = "1px"; ta.style.height = "1px"; ta.style.padding = 0; ta.style.border = "none"; ta.style.outline = "none"; ta.style.boxShadow = "none"; ta.style.background = "transparent";
        document.body.appendChild(ta);
        ta.focus(); ta.select();
        return new Promise((res, rej) => {
            try {
                document.execCommand('copy') ? res() : rej(new Error('Copy command failed'));
            } catch (err) { rej(err); }
            finally { document.body.removeChild(ta); }
        });
    }

    function handleCopyCommand() {
        const allAiMessages = Array.from(document.querySelectorAll('.ai-message .message-bubble p'));
        if (allAiMessages.length === 0) {
            return Promise.reject(new Error("No messages to copy."));
        }
        let targetMessage = allAiMessages.slice().reverse().find(p => p.dataset.messageType === 'definition') || allAiMessages[allAiMessages.length - 1];
        const clone = targetMessage.cloneNode(true);
        clone.querySelectorAll('.suggestion-link').forEach(link => link.remove());
        clone.querySelectorAll('.comment-section').forEach(comment => comment.remove());
        const textToCopy = clone.innerText;
        return copyToClipboard(textToCopy.trim());
    }

    function initializeRippleEffect() {
        document.body.addEventListener('mousedown', applyRippleEffect);
        document.body.addEventListener('touchstart', applyRippleEffect, { passive: true });
    }

    function applyRippleEffect(e) {
    const button = e.target.closest('.has-ripple');
    if (!button) return;
    const rect = button.getBoundingClientRect();
    button.querySelector(".ripple")?.remove();
    const circle = document.createElement("span");
    const diameter = Math.max(button.clientWidth, button.clientHeight);
    const radius = diameter / 2;
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    circle.style.width = circle.style.height = `${diameter}px`;
    circle.style.left = `${clientX - rect.left - radius}px`;
    circle.style.top = `${clientY - rect.top - radius}px`;
    circle.classList.add("ripple");
    
    button.appendChild(circle);
    setTimeout(() => circle.remove(), 600);
}

    document.addEventListener('click', function (e) {
        const suggestionLink = e.target.closest('.suggestion-link');
        if (suggestionLink) {
            e.preventDefault();
            if (isLoading || isAITyping || input.disabled) return;

            chatContainer.classList.add('is-loading');

            processWordSubmission(suggestionLink.dataset.word);
        }
    });

    function displayMessage(text, sender) {
        const wrapper = document.createElement('div');
        wrapper.className = `message-wrapper ${sender === 'user' ? 'user-message' : 'ai-message'}`;

        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'message-content-wrapper';

        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';

        const p = document.createElement('p');
        p.innerHTML = text;
        bubble.appendChild(p);
        
        contentWrapper.appendChild(bubble);
        wrapper.appendChild(contentWrapper);
        chatContainer.appendChild(wrapper);

        if (sender === 'user') {
            const pStyle = window.getComputedStyle(p);
            const lineHeight = parseFloat(pStyle.lineHeight) || (parseFloat(pStyle.fontSize) * 1.5);
            const maxHeight = lineHeight * 5.1; 

            if (p.scrollHeight > maxHeight) {
                bubble.classList.add('truncated');

                const readMore = document.createElement('div');
                readMore.className = 'read-more-indicator';
                readMore.innerHTML = '<span class="material-symbols-outlined">more_horiz</span>';

                bubble.appendChild(readMore);
            }
        }
        
        smoothScrollToBottom(chatContainer, 400);

        return wrapper;
    }

    function typewriterEffect(el, txt, onComplete) {
      if (!txt) { el.innerHTML = "<span class='italic text-gray-500'>Information not found.</span>"; if(onComplete) onComplete(); return; }
      stopAll();
      isAITyping = true;
      chatContainer.classList.add('ai-is-typing');
      updateSubmitButtonState();
      updateLanguageTagOnScroll();
      if (liveScrollAnimationId === null) liveScrollAnimationId = requestAnimationFrame(liveSmoothScroll);
      let i = 0;
      let currentVisibleText = "";
      const cursorSpan = '<span class="typing-cursor">●</span>';
      el.innerHTML = cursorSpan;
      typewriterInterval = setInterval(() => {
        if (i < txt.length) {
          if (txt.charAt(i) === '<') {
            const endIndex = txt.indexOf('>', i);
            currentVisibleText += txt.substring(i, endIndex !== -1 ? endIndex + 1 : txt.length);
            i = endIndex !== -1 ? endIndex : txt.length -1;
          } else {
            currentVisibleText += txt.charAt(i);
          }
          i++;
          el.innerHTML = currentVisibleText + cursorSpan;
        } else {
          el.innerHTML = currentVisibleText;
          stopAll();
          if (onComplete) onComplete();
        }
      }, 35);
    }

    function stopAll() {
        if (typewriterInterval) clearInterval(typewriterInterval);
        if (thinkingTimeout) clearTimeout(thinkingTimeout);
        if (liveScrollAnimationId) cancelAnimationFrame(liveScrollAnimationId);

        typewriterInterval = null;
        thinkingTimeout = null;
        liveScrollAnimationId = null;

        const lastBubble = chatContainer.querySelector('.message-wrapper:last-child .loading-dots');
        if (lastBubble) {
            lastBubble.closest('.message-wrapper').remove();
        }
        document.querySelector('.typing-cursor')?.remove();

        isLoading = false;
        isAITyping = false;

        chatContainer.classList.remove('is-loading', 'ai-is-typing');
        updateSubmitButtonState();
        updateLanguageTagOnScroll();
    }

    function findWordEntry(word) {
        const lowerWord = word.toLocaleLowerCase('tr-TR');
        if (vocabularyData[lowerWord]) return vocabularyData[lowerWord];
        for (const key in vocabularyData) {
            const entry = vocabularyData[key];
            if (entry.alternatives?.map(a => a.toLocaleLowerCase('tr-TR')).includes(lowerWord)) return entry;
        }
        return null;
    }

    let lastKnownVisibleLanguage = null;

    function updateLanguageTagOnScroll() {
        const footerIndicatorContainer = document.getElementById('footer-indicator-container');
        const messagesWithLang = document.querySelectorAll('.ai-message .message-bubble p[data-language]');
        const containerRect = chatContainer.getBoundingClientRect();

        let lastVisibleMessage = null;

        for (let i = messagesWithLang.length - 1; i >= 0; i--) {
            const msg = messagesWithLang[i];
            const msgRect = msg.getBoundingClientRect();
            if (msgRect.top < containerRect.bottom && msgRect.bottom > containerRect.top) {
                lastVisibleMessage = msg;
                break;
            }
        }

        const targetLanguage = lastVisibleMessage ? lastVisibleMessage.dataset.language : null;
        let finalIndicatorState = targetLanguage; 
        
        if (isLoading && !userHasScrolledUp) {
            finalIndicatorState = 'thinking';
        }

        if (finalIndicatorState !== lastKnownVisibleLanguage) {
            footerIndicatorContainer.innerHTML = ''; 

            if (finalIndicatorState) { 
                const languageTag = document.createElement('span');
                let tagClass = '';
                
                if (finalIndicatorState === 'thinking') {
                    tagClass = 'thinking-indicator';
                } else if (finalIndicatorState === 'system') {
                    tagClass = 'system-indicator';
                } else if (finalIndicatorState === 'welcome') {
                    tagClass = 'welcome-indicator';
                } else {
                    tagClass = 'language-info';
                }

                languageTag.className = `${tagClass} tag-anim-in`;
                languageTag.textContent = finalIndicatorState;
                footerIndicatorContainer.appendChild(languageTag);
            }

            lastKnownVisibleLanguage = finalIndicatorState;
            setTimeout(handleIndicatorOverlap, 50);
        }
    }

    function animateCommentSection(commentContainer) {
        const commentWords = Array.from(commentContainer.querySelectorAll('.comment-word'));
        if (commentWords.length === 0) return;

        commentContainer.classList.add('visible');

        let delay = 50;
        const delayIncrement = 50;

        commentWords.forEach(word => {
            setTimeout(() => {
                word.classList.add('visible');
            }, delay);
            delay += delayIncrement;
        });

        const totalDuration = delay;
        setTimeout(() => smoothScrollToBottom(chatContainer, 300), totalDuration);
    }
    
    function getAIResponse(word) {
        stopAll();

        if (word.toLowerCase() === 'copy') {
            isLoading = true;
            chatContainer.classList.add('is-loading');
            const loadingMessageWrapper = displayMessage(`<div class="loading-dots"><span></span><span></span><span></span><span></span></div>`, "ai");
            updateSubmitButtonState();
            updateLanguageTagOnScroll();
            
            const thinkingTime = 2000 + (300 + Math.random() * 400); 

            thinkingTimeout = setTimeout(() => {
                isLoading = false;
                loadingMessageWrapper.remove();
                handleCopyCommand()
                    .then(() => {
                        const p = displayMessage("", "ai").querySelector('p');
                        p.dataset.language = 'system';
                        typewriterEffect(p, "Message copied.");
                    })
                    .catch(err => {
                        console.error(err);
                        const p = displayMessage("", "ai").querySelector('p');
                        p.dataset.language = 'system';
                        typewriterEffect(p, "Could not find a message to copy.");
                    });
                updateSubmitButtonState();
            }, thinkingTime);
            return;
        }

        isLoading = true;
        chatContainer.classList.add('is-loading');
        const messageWrapper = displayMessage(`<div class="loading-dots"><span></span><span></span><span></span><span></span></div>`, "ai");
        updateSubmitButtonState();
        updateLanguageTagOnScroll();

        let thinkingTime = 0;
        const data = findWordEntry(word);
        let suggestions = [];

        if (data) {
            thinkingTime += (data.meaning || '').length * 30;
            thinkingTime += (data.etymology || '').length * 60;

            let dynamicSuggestions = [];
            if (data.etymology) {
                const etymologyLines = data.etymology.split('<br>');
                for (const line of etymologyLines) {
                    const potentialWords = line.split(' ');
                    for (const pWord of potentialWords) {
                        const cleanWord = pWord.replace(/<[^>]*>/g, "").replace(/[.,!?]/g, '').trim();
                        if (cleanWord && findWordEntry(cleanWord) && !dynamicSuggestions.includes(cleanWord)) {
                            dynamicSuggestions.push(cleanWord);
                        }
                    }
                }
            }
            const lowerWord = word.toLocaleLowerCase('tr-TR');
            const wordBacklinks = backlinksData[lowerWord];
            if (wordBacklinks) {
                const allBacklinks = [...(wordBacklinks.direct || []), ...(wordBacklinks.related || [])];
                allBacklinks.forEach(backlinkWord => {
                    if (findWordEntry(backlinkWord) && !dynamicSuggestions.includes(backlinkWord)) {
                        dynamicSuggestions.push(backlinkWord);
                    }
                });
            }
            suggestions = [...new Set(dynamicSuggestions)];
            thinkingTime += suggestions.length * 90;
        } else {
            suggestions = getClosestWords(word, 5);
            thinkingTime += suggestions.length * 30;
        }

        thinkingTime += 500 + Math.random() * 1000;
        const p = messageWrapper.querySelector('p');

        thinkingTimeout = setTimeout(() => {
            isLoading = false;
            p.innerHTML = '';

            const footerIndicatorContainer = document.getElementById('footer-indicator-container');
            footerIndicatorContainer.innerHTML = '';

            if (data && data.language) {
                p.dataset.language = data.language;
                const languageTag = document.createElement('span');
                languageTag.className = 'language-info tag-anim-in';
                languageTag.textContent = data.language;
                footerIndicatorContainer.appendChild(languageTag);
                lastKnownVisibleLanguage = data.language;
            } else {
                lastKnownVisibleLanguage = null;
            }

            setTimeout(handleIndicatorOverlap, 50);

            let messageText = "";
            let commentText = "";
            let suggestionsHTML = "";
            
            if (data) {
                if (data.vocabId) {
                    const idSpan = document.createElement('span');
                    idSpan.className = 'message-meta';
                    idSpan.textContent = data.vocabId;
                    messageWrapper.appendChild(idSpan);
                    // ### UPDATED CODE ###
                    history.pushState(null, null, '#' + data.vocabId);
                }
                
                p.dataset.messageType = 'definition';

                let meaningHTML = data.meaning ? data.meaning.split(';').map((item, index) => `<k>${index + 1}.</k> ${item.trim()}`).join('<br>') : '';
                
                let etymologyHTML = "";
                if (data.etymology) {
                    const etymologyLines = data.etymology.split('<br>');
                    const processedLines = etymologyLines.map(line => {
                        const etymologyWords = line.split(' ');
                        const processedEtymologyWords = etymologyWords.map(etymWord => {
                            const prefixMatch = etymWord.match(/^[<≈]/);
                            const prefix = prefixMatch ? prefixMatch[0] : '';
                            const wordToClean = prefix ? etymWord.substring(1) : etymWord;
                            const cleanWord = wordToClean.replace(/<[^>]*>/g, "").replace(/[.,!?]/g, '').trim();
                            
                            if (cleanWord) {
                                const entry = findWordEntry(cleanWord);
                                if (entry) {
                                    return `${prefix}<b>${entry.language}</b> <y>${cleanWord}</y> “${entry.meaning}”`;
                                }
                            }
                            return etymWord;
                        });
                        return processedEtymologyWords.join(' ');
                    });
                    etymologyHTML = processedLines.join('<br>');
                }

                let backlinksText = "";
                const lowerWord = word.toLocaleLowerCase('tr-TR');
                const wordBacklinks = backlinksData[lowerWord];
                if (wordBacklinks) {
                    const allBacklinks = [];
                    const processBacklink = (backlinkWord, prefix) => {
                        const entry = findWordEntry(backlinkWord);
                        if (entry) {
                            const richFormat = `<b>${entry.language}</b> <y>${backlinkWord}</y> “${entry.meaning}”`;
                            allBacklinks.push(`${prefix} ${richFormat}`);
                        }
                    };

                    if (wordBacklinks.direct && wordBacklinks.direct.length > 0) {
                        wordBacklinks.direct.sort((a, b) => a.localeCompare(b, 'tr-TR'));
                        wordBacklinks.direct.forEach(bw => processBacklink(bw, '&gt;'));
                    }
                    if (wordBacklinks.related && wordBacklinks.related.length > 0) {
                        wordBacklinks.related.sort((a, b) => a.localeCompare(b, 'tr-TR'));
                        wordBacklinks.related.forEach(bw => processBacklink(bw, '&approx;'));
                    }
                    if (allBacklinks.length > 0) {
                        backlinksText = `<br>${allBacklinks.join('<br>')}`;
                    }
                }
                
                if (suggestions.length > 0) {
                    suggestionsHTML = `<div class="flex flex-wrap mt-3">` +
                                     suggestions.map(s => `<a href="#" class="suggestion-link has-ripple px-3 py-1 rounded-full" data-word="${s}">${s}</a>`).join('') +
                                     `</div>`;
                }
                
                messageText = meaningHTML + (etymologyHTML ? '<br>' + etymologyHTML : '') + backlinksText;

                if (data.comment && data.comment.trim() !== '') {
                    commentText = data.comment;
                }

            } else {
                p.dataset.language = 'system';
                messageText = `No results found; after all, the limits of my vocabulary are the limits of my world. :3`;
                suggestionsHTML = `<div class="flex flex-wrap mt-2">` +
                                  suggestions.map(s => `<a href="#" class="suggestion-link has-ripple px-3 py-1 rounded-full" data-word="${s}">${s}</a>`).join('') +
                                  `</div>`;
            }

            const onCompleteCallback = () => {
                const bubble = p.closest('.message-bubble');
                if (!bubble) return;

                let hasAnimatedContent = false;
                if (commentText) {
                    const commentSection = document.createElement('div');
                    commentSection.className = 'comment-section';
                    const linesHTML = commentText.split('\n').map(line => {
                        return line.split(' ').filter(word => word.trim() !== '').map(word => `<span class="comment-word">${word}</span>`).join(' ');
                    }).join('<br>');
                    commentSection.innerHTML = `<p>${linesHTML}</p>`;
                    bubble.appendChild(commentSection);
                    setTimeout(() => animateCommentSection(commentSection), 100);
                    hasAnimatedContent = true;
                }

                if (suggestionsHTML) {
                    const tempContainer = document.createElement('div');
                    tempContainer.innerHTML = suggestionsHTML;
                    const suggestionNode = tempContainer.firstChild;
                    if(suggestionNode) {
                        bubble.appendChild(suggestionNode);
                        const buttons = Array.from(suggestionNode.querySelectorAll('.suggestion-link'));
                        buttons.forEach((button, index) => {
                            const animationDelay = hasAnimatedContent ? 500 : 100;
                            setTimeout(() => button.classList.add('visible'), animationDelay + (index * 100));
                        });
                    }
                }

                smoothScrollToBottom(chatContainer, 400);
            };

            typewriterEffect(p, messageText, onCompleteCallback);

        }, thinkingTime);
    }
    const container = document.querySelector('#chat-container');
let velocity = 0;
const friction = 0.98; // 0.90–0.98 arası doğal bir momentum için ideal

container.addEventListener('wheel', e => {
    velocity += e.deltaY;
    e.preventDefault();
    requestAnimationFrame(momentumScroll);
});

function momentumScroll() {
    if (Math.abs(velocity) > 0.5) {
        container.scrollTop += velocity;
        velocity *= friction;
        requestAnimationFrame(momentumScroll);
    }
}
    function levenshtein(a, b) {
      if(a.length === 0) return b.length; if(b.length === 0) return a.length;
      const m = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
      for(let i=0; i<=a.length; i++) m[0][i]=i; for(let j=0; j<=b.length; j++) m[j][0]=j;
      for(let j=1; j<=b.length; j++) for(let i=1; i<=a.length; i++) {
        const cost = a[i-1] === b[j-1] ? 0 : 1;
        m[j][i] = Math.min(m[j][i-1] + 1, m[j-1][i] + 1, m[j-1][i-1] + cost);
      }
      return m[b.length][a.length];
    }

    function getClosestWords(word, count) {
      if (Object.keys(vocabularyData).length === 0) return [];
      const lowerWord = word.toLocaleLowerCase('tr-TR');
      return Object.keys(vocabularyData)
        .map(w => ({
            originalWord: w,
            dist: levenshtein(lowerWord, w.toLocaleLowerCase('tr-TR'))
        }))
        .sort((a, b) => a.dist - b.dist)
        .slice(0, count)
        .map(d => d.originalWord);
    }

    function initializeOverscrollEffect() {
        const container = chatContainer;
        let isDragging = false;
        let startY = 0;
        let currentTranslate = 0;
        let velocity = 0;
        let animationFrameId = null;

        const stiffness = 0.15;
        const damping = 0.3;
        const mass = 1;
        const dragDamping = 0.2;

        function startDrag(y) {
            if (container.scrollTop === 0 || container.scrollTop + container.clientHeight >= container.scrollHeight - 1) {
                isDragging = true;
                startY = y;
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                velocity = 0;
                container.style.transition = 'none';
            }
        }

        function onDrag(y) {
            if (!isDragging) return;

            const deltaY = y - startY;
            const atTop = container.scrollTop === 0;
            const atBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 1;

            if ((atTop && deltaY > 0) || (atBottom && deltaY < 0)) {
                currentTranslate += (y - startY) * dragDamping;
                startY = y;
                applyTransform();
            } else {
                isDragging = false;
                animateReturn();
            }
        }

        function endDrag() {
            if (isDragging) {
                isDragging = false;
                animateReturn();
            }
        }

        function applyTransform() {
            container.style.transform = `translateY(${currentTranslate}px)`;
        }

        function animateReturn() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            function step() {
                const force = -stiffness * currentTranslate;
                const acceleration = force / mass;
                velocity += acceleration;
                velocity *= damping;
                currentTranslate += velocity;

                applyTransform();

                if (Math.abs(currentTranslate) < 0.1 && Math.abs(velocity) < 0.1) {
                    currentTranslate = 0;
                    velocity = 0;
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    container.style.transform = '';
                } else {
                    animationFrameId = requestAnimationFrame(step);
                }
            }
            
            animationFrameId = requestAnimationFrame(step);
        }

        container.addEventListener('touchstart', (e) => startDrag(e.touches[0].clientY), { passive: true });
        container.addEventListener('touchmove', (e) => {
            if(isDragging) e.preventDefault();
            onDrag(e.touches[0].clientY);
        }, { passive: false });
        container.addEventListener('touchend', endDrag);
        container.addEventListener('touchcancel', endDrag);

        let wheelTimeout;
        container.addEventListener('wheel', (e) => {
            const atTop = container.scrollTop === 0;
            const atBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 1;

            if ((e.deltaY < 0 && atTop) || (e.deltaY > 0 && atBottom)) {
                e.preventDefault();
                clearTimeout(wheelTimeout);
                
                velocity -= e.deltaY * 0.1;
                
                if (!animationFrameId) {
                     animateReturn();
                }
                
                wheelTimeout = setTimeout(() => {
                     if(!isDragging && animationFrameId) {
                     }
                }, 150);
            }
        }, { passive: false });
    }

  </script>
</body>
</html>
